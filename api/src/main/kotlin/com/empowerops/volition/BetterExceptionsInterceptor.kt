package com.empowerops.volition

import com.google.protobuf.Any
import com.google.protobuf.Message
import com.google.protobuf.kotlin.isA
import com.google.protobuf.kotlin.unpack
import com.google.rpc.Code
import com.google.rpc.DebugInfo
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.ClientCall
import io.grpc.ClientInterceptor
import io.grpc.ForwardingClientCall
import io.grpc.ForwardingClientCallListener
import io.grpc.ForwardingServerCall
import io.grpc.Metadata
import io.grpc.MethodDescriptor
import io.grpc.ServerCall
import io.grpc.ServerCallHandler
import io.grpc.ServerInterceptor
import io.grpc.protobuf.lite.ProtoLiteUtils
import java.util.logging.Level
import java.util.logging.Logger

/**
 * The default maximum size for GRPC headers; set individually on client and server.
 * Note that 8k is really small for purposes of exceptions.
 */
const val DEFAULT_MAX_HEADER_SIZE = 8192

/**
 * Server & Client adapter to add better exceptions to add exceptions to the wire server-side,
 * and to pull exceptions from the wire client-side.
 *
 * This Interceptor attempts to, as conventionally as possible, inspect status' and,
 * if they indicate a failure, pull a suitable exception (message & stack-trace) from the server,
 * serialize it as a [DebugInfo] on the wire, and pull it off the wire client side,
 * and give it to GRPC to re-throw.
 *
 * **Important note**: Using [DebugInfo] to serialize java exceptions can result in really
 * large instances. Because GRPC puts [io.grpc.Status] codes in the header (metadata), this means
 * you can have very large metadata paylods. The default is [DEFAULT_MAX_HEADER_SIZE] (8kb).
 * This class will drop details to force the resulting Status to fit in half of the
 * provided [maxMetadataSize].
 *
 * _Suggestion: use [io.grpc.ManagedChannelBuilder.maxInboundMetadataSize] to increase the
 * maximum header size, pass the value passed in there to [maxMetadataSize]_
 *
 * @param maxMetadataSize the maximum size of client-allowed headers;
 * exceptions generated by this class will not use more than half the provided space value.
 */
class BetterExceptionsInterceptor(val maxMetadataSize: Int): ClientInterceptor, ServerInterceptor {

    companion object {
        val USE_UNLIMITED_SIZE_DEBUG_INFO_KEY = BetterExceptionsInterceptor::class.qualifiedName + "." + (::UseUnlimitedSizeDebugInfo).name
        val UseUnlimitedSizeDebugInfo: Boolean = System.getProperty(USE_UNLIMITED_SIZE_DEBUG_INFO_KEY, "false").lowercase() == "true"

        val Log = Logger.getLogger(BetterExceptionsInterceptor::class.qualifiedName)
    }

    // intercept Client Calls
    override fun <Q, R> interceptCall(
        method: MethodDescriptor<Q, R>,
        callOptions: CallOptions,
        channel: Channel
    ): ClientCall<Q, R> {
        val callDelegate = channel.newCall(method, callOptions)
        return BetterExceptionClientCall<Q, R>(callDelegate, method)
    }

    // intercept Server Calls
    override fun <Q, R> interceptCall(
        call: ServerCall<Q, R>,
        headers: Metadata,
        next: ServerCallHandler<Q, R>
    ): ServerCall.Listener<Q> {
        val callInterceptor = BetterExceptionsServerCall(call)
        return next.startCall(callInterceptor, headers)
    }

    inner class BetterExceptionsServerCall<Q, R>(
        private val callDelegate: ServerCall<Q, R>
    ) : ForwardingServerCall<Q, R>() {

        override fun delegate(): ServerCall<Q, R> = callDelegate
        override fun close(status: io.grpc.Status, trailers: Metadata){
            val cause = status.cause

            // I would like to call StatusProto.packToGrpcStatus or something here,
            // but that requires exception flow, which is no longer possible since we're out of service code
            // so I've copied some of its implementation here regarding STATUS_DETAILS_KEY
            // and am hoping I won't see breakage.
            if( ! status.isOk && cause != null) {

                val status = when {
                    UseUnlimitedSizeDebugInfo -> {
                        convertToExtendedStatusWithDebugInfo(status, dropRedundantFrames = false, maxFramesPerCause = Int.MAX_VALUE)
                    }
                    else -> {
                        val statusesOfDecreasingDetail = sequence<com.google.rpc.Status> {
                            // hmmmmm theres actuall a b-search here...
                            yield(convertToExtendedStatusWithDebugInfo(
                                status,
                                dropRedundantFrames = false,
                                maxFramesPerCause = Int.MAX_VALUE
                            ))
                            yield(convertToExtendedStatusWithDebugInfo(status, true, Int.MAX_VALUE))
                            yield(convertToExtendedStatusWithDebugInfo(status, true, 100))
                            yield(convertToExtendedStatusWithDebugInfo(status, true, 20))
                            yield(convertToExtendedStatusWithDebugInfo(status, true, 2))
                            yield(convertToExtendedStatusWithDebugInfo(status, true, 0))
                        }

                        val maxDedicatedHeaderBytes = 0.5 * maxMetadataSize

                        val result = statusesOfDecreasingDetail.firstOrNull { it ->
                            it.serializedSize < maxDedicatedHeaderBytes
                        }

                        result
                    }
                }

                if(status == null)
                    Log.warning("failed to fit server side exception into metadata header (size=$maxMetadataSize bytes); forced to drop exception") else
                    trailers.put(STATUS_DETAILS_KEY, status)
            }
            // server-side close; trailers now contains a ExtendedStatus/DebugInfo
            super.close(status, trailers)
        }
    }

    inner class BetterExceptionClientCall<Q, R>(
        private val callDelegate: ClientCall<Q, R>,
        method: MethodDescriptor<Q, R>
    ): ForwardingClientCall<Q, R>() {

        // at ClientCall constructor time we're gonna snapshot the stack.
        // - this should be substantially faster than any message transfer time --even if on the same machine
        // - with GRPC 1.68, this includes the stack to the rpc method on UNARY's, and `collect` on SERVER_STREAM.
        //    - this should be pretty universally sufficient
        //    - unfortunately GRPC actually uses cold flows for SERVER_STREAM,
        //      meaning its impossible to get any code running downstack from the actual rpc method invocation on the stub :(
        // this information is likely very important for making heads-or-tails in a really async-ee system.
        private val sourceEx =
            RemoteProcedureCallClientException("failure on client invoke-rpc ${method.fullMethodName}")
        // do NOT give this a source; one will be provided later if needed.
        // note: perf here is effectively the performance of a memcpy on the stack; which is pretty fast,
        // the slow part is actually disassembling the backtrace to a stackTrace, which only happens
        // at rendering time.

        override fun delegate(): ClientCall<Q, R> = callDelegate
        override fun start(listenerDelegate: Listener<R>, headers: Metadata) {
            val listener = BetterExceptionClientCallListener(listenerDelegate, sourceEx)
            callDelegate.start(listener, headers)
        }
    }

    inner class BetterExceptionClientCallListener<R>(
        val listenerDelegate: ClientCall.Listener<R>,
        val clientSideSource: Exception
    ) : ForwardingClientCallListener<R>() {

        override fun delegate(): ClientCall.Listener<R> = listenerDelegate

        // aims to build a Status object with a cause that has this:
        // Client-side wrapper: failure from server
        // at [5] [here]
        // at [6] kotlinx.kruft
        // at [7] grpc.garbage
        // at [8] kotlinx.kruft
        // at [9] flow.consume -- as close to client.rpcMethod as can get
        // at [10] clientEntry
        // at [11] main
        // at [..]
        // caused-by: Server-side Wrapper-Explosion: MyService.faultyDomainFunction
        // at [2] server.rpcMethod
        // at [3] grpc.serverGarbage
        // at [4] netty.nonsense
        // caused-by: Server-side Root-Explosion: Serializer.doSerialize
        // at [0] MyService.serializeThings
        // at [1] yourRootCausesExecutionContext
        // probably at [3]....
        fun makeBetter(defaultStatus: io.grpc.Status, trailers: Metadata): io.grpc.Status {

            val extendedStatus = trailers.get(STATUS_DETAILS_KEY)
            val debugInfos = extendedStatus?.detailsList?.mapNotNull { it.unpackOrNull<DebugInfo>() } ?: emptyList()

            var exception: Throwable? = when {
                debugInfos.isEmpty() -> {
                    // nothing we can add, `cause` is also probably null but somebody may have built it.
                    defaultStatus.cause
                }
                defaultStatus.isOk -> defaultStatus.cause.also {
                    Log.warning("status OK contains DebugInfo. Skipping.\nstatus=$defaultStatus\ndebugInfos=$debugInfos")
                }
                debugInfos.any() -> {

                    // the bottom cause of debugInfos is at lastIndex, the top level exception is at debugInfos[0].
                    // starting from the lowest level cause means we can simply call the regular constructor-with cause, so reverse it
                    val causeOrderedChain = debugInfos.reversed()

                    // this lets us build the server half
                    // Server-side Wrapper-Explosion: MyService.faultyDomainFunction
                    // at [2] server.rpcMethod
                    // at [3] grpc.serverGarbage
                    // at [4] netty.nonsense
                    // caused-by: Server-side Root-Explosion: Serializer.doSerialize
                    // at [0] MyService.serializeThings
                    // at [1] yourRootCausesExecutionContext
                    // probably at [3]....
                    var exception: Throwable? = causeOrderedChain.fold<_, RemoteProcedureCallServerException?>(null) { cause, nextDebugInfo ->
                        RemoteProcedureCallServerException(nextDebugInfo, cause)
                    }

                    exception
                }
                else -> TODO()
            }

            // clientSideSource contains the client half, so we'll stitch the server side portion in as a cause.
            // which should give us
            // Client-side wrapper: failure from server
            // at [5] [here]
            // at [6] kotlinx.kruft
            // at [7] grpc.garbage
            // at [8] kotlinx.kruft
            // at [9] flow.consume -- as close to client.rpcMethod as can get
            // at [10] clientEntry
            // at [11] main
            // at [..]
            // caused-by: Server-side Wrapper-Explosion: MyService.faultyDomainFunction
            // at [2] server.rpcMethod
            // at [3] ...as Above...
            exception = clientSideSource.initCause(exception)

            // this wrapper seems useless, onClose() is a scheduled callback interally from GRPC.
            // all the context this seems to give us is grpc gunk.
//            exception = RemoteProcedureCallClientException("on-close $methodName", exception)

            return defaultStatus
                .withDescription(defaultStatus.description ?: "RPC failure")
                .withCause(exception)
        }

        override fun onClose(status: io.grpc.Status, trailers: Metadata) {
            val betterStatus = try {
                makeBetter(status, trailers)
            }
            catch(ex: Throwable) {
                Log.log(Level.SEVERE, "internal error in client-side exception retrieval", ex)
                status
            }
            // this is client-side
            super.onClose(betterStatus, trailers)
        }
    }
}

// see io.grpc.protobuf.StatusProto.STATUS_DETAILS_KEY
private val STATUS_DETAILS_KEY: Metadata.Key<com.google.rpc.Status> = Metadata.Key.of(
    "grpc-status-details-bin",
    ProtoLiteUtils.metadataMarshaller<com.google.rpc.Status>(com.google.rpc.Status.getDefaultInstance())
)

// oook, I'm not a fan of the GRPC API
// I get the feeling that if you can keep it straight in your head which object your extending,
// you might be able to understasnd what's happening,
// but the signature `fun start(callState: CallState): Listener`
// breaks my brain.
//
// anyways, tl;dr, I've decided I will:
// - use named classes. do not use anonymous overloads as it creates callback hell.
// - use GRPC's built in `ForwardingXYZ` class, and override the delegate method. Don't try to force kotlin idioms.

// some references:
// see https://stackoverflow.com/a/48750825/1307108
// also https://www.youtube.com/watch?v=F2WYEFLTKEw (circa 2018)


class RemoteProcedureCallServerException internal constructor(
    val debugInfo: DebugInfo, cause: Exception? = null
): RuntimeException(debugInfo.detail){

    companion object {
        val UNINITIALIZED_SERVER_TRACE = emptyArray<StackTraceElement>()
    }

    init {
        stackTrace = debugInfo.stackEntriesList
            .map { fromStrictStackEntryDataClassString(it) }
            .toTypedArray()

        if(cause != null) initCause(cause)
    }

    override fun fillInStackTrace(): Throwable {
        stackTrace = UNINITIALIZED_SERVER_TRACE
        return this
    }

    override fun toString() = buildString {
        append("server-side")
        if(localizedMessage != null || message != null) append(": ").append(localizedMessage ?: message)
    }
}

class RemoteProcedureCallClientException internal constructor(
    message: String, // needed because the default error message will give you the cause's message; which can be confusing.
): RuntimeException(message)

private fun convertToExtendedStatusWithDebugInfo(
    basicStatus: io.grpc.Status,
    dropRedundantFrames: Boolean,
    maxFramesPerCause: Int
): com.google.rpc.Status {
    require(maxFramesPerCause >= 0)

    val ex = basicStatus.cause!!
    val description = basicStatus.description ?: "unknown-error"

    val causes = generateSequence(ex) { ex -> ex.cause.takeUnless { it == ex } }
        .toList()
    val alreadyRenderedFrames = HashSet<StackTraceElement>()

    val debugInfos = causes.map { ex ->
        val originalFrames = ex.stackTrace.asList()
        var modified = false

        val dedupedFrames = originalFrames
            .dropLastWhile { dropRedundantFrames && alreadyRenderedFrames.add(it) }
        modified = modified || dedupedFrames != originalFrames

        val croppedFrames = if(maxFramesPerCause == 0) emptyList() else dedupedFrames.take((maxFramesPerCause-1))
        modified = modified || croppedFrames != dedupedFrames

        val ammendedFrames = if( ! modified)
            croppedFrames else
            (croppedFrames + StackTraceElement("_OMITTED._FRAMES", "_", null, -1))

        val serializedFrames = ammendedFrames.map { toStrictStackEntryDataClassString(it) }

        DebugInfo.newBuilder()
            .setDetail(ex.toString())
            .addAllStackEntries(serializedFrames)
            .build()
    }

    val status = com.google.rpc.Status.newBuilder()
        .setCode(Code.INTERNAL_VALUE)
        .setMessage(description)
        .addAllDetails(debugInfos.map { com.google.protobuf.Any.pack(it) })
        .build()

    return status
}

private const val NO_SOURCE_LINE_NUMBER = "0"

/**
 * Converts a provided stack trace element into a readable & parsable string, in the exact form
 *
 * _class-name_ __.__ _method-name_ __(__ _source_ __)__
 *
 * Notably:
 * - never include the classloader (which is usually omitted in a [StackTraceElement.toString])
 * - never include the module name (which is often omitted in a [StackTraceElement.toString]),
 * - never include the module version (which is often omitted ..)
 * - always include the class (which is also always included in [StackTraceElement.toString])
 *    - TODO: what does a project-lyden style top-level function have as its class?
 * - always include the method name
 * - always include a source reference, which is one of
 *     - exactly "Unknown Source"
 *     - exactly "Native Method"
 *     - exactly _file-name_ __:__ _line-number_,
 *       if the line number isn't known it is printed as `0` ([NO_SOURCE_LINE_NUMBER]).
 *
 * examples:
 * - com.foo.Main.run(Main.java:101)
 * - com.foo.Main.run(Main.java:0)
 * - com.foo.Main.run(Unknown Source)
 * - com.foo.Main.run(Native Method)
 * - com.foo.bar.App.run(App.java:12)
 * - org.acme.LibKt.test(Lib.kt:80)
 * - MyClass.mash(MyClass.java:9)
 *
 * This is captured in [StackTraceElementRegex]
 */
private fun toStrictStackEntryDataClassString(traceElement: StackTraceElement): String {

    val className = traceElement.className
    val methodName = traceElement.methodName

    val source = traceElement.run { when {
        isNativeMethod -> "Native Method"
        fileName == null -> "Unknown Source"
        lineNumber > 0 -> "$fileName:$lineNumber"
        fileName != null -> "$fileName:$NO_SOURCE_LINE_NUMBER"
        else -> TODO()
    }}

    val result = buildString {
        append(className).append('.').append(methodName)
        append('(').append(source).append(')')
    }

    require(StackTraceElementRegex.matches(result)) {
        "postcondition: resulting stack-trace element string doesnt match regex: $result"
    }

    return result
}

private val StackTraceElementRegex = Regex(
    "(?<className>[^(\\s]+)\\.(?<methodName>[^(]+)\\((?<source>[^)]+)\\)$"
)

private fun fromStrictStackEntryDataClassString(strictTraceElementString: String): StackTraceElement {
    val match = StackTraceElementRegex.matchEntire(strictTraceElementString.trim())
    require(match != null) { "cant parse as StackTraceElement: $strictTraceElementString" }

    val (className, methodName, source) = match.destructured

    val pseudoFileName = when(source) {
        "Unknown Source" -> null
        else -> source.substringBefore(':')
    }
    val pseudoLineNumber = when(source){
        "Native Method" -> -2
        "Unknown Source" -> -1
        else -> source.substringAfter(':').toIntOrNull() ?: -1
    }

    val result = StackTraceElement(
        className,
        methodName,
        pseudoFileName,
        pseudoLineNumber
    )
    return result
}

private inline fun <reified T: Message> Any.unpackOrNull(): T? {
    return if(this.isA<T>()) this.unpack<T>() else null
}