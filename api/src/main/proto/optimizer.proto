syntax = "proto3";

option optimize_for = CODE_SIZE;
option java_multiple_files = true;
option java_package = "com.empowerops.volition.dto";
option csharp_namespace = "EmpowerOps.Volition.DTO";

package empowerops.volition.api;

import "google/protobuf/duration.proto";
import "google/protobuf/wrappers.proto";

service Optimizer {

    //some design considerations:
    // 1. this is a peer'd relationship, *not* a client-server relationship.
    //    (because either end point, OASIS or the plugin, may decide to issue a command or ask a query)

    // attempt 1:
    // so: one solution is to simply use grpc BIDI streams.
    //    ie: rpc doEverything(stream clientRequestsAndResponses) returns (stream oasisRequestsAndResponses)
    //    the problem: this gets into some real nasty stateful multiplexing. When you read a message you would have to
    //    determine if its a query or a response, and, if its a response, find the context of the code that submitted the query.
    //    this happens in a full-multiplex environment where OASIS would make no gaurentees
    //    that the next message you recieve after submitting a query is the answer to your query
    //    (it would be race-condition-hell to do otherwise)
    //    so, a client would, have to decode a message to discover "oh this is a response to the 'XYZquery'
    //    I submitted earlier, then it would have to find any necessary state associated with that query
    //    (typically stack variables, but here this wouild likely push callers into state machines to keep that info)
    //    restore that state (ie back to useful stack variables), then continue their business logic.
    //    this will be bug ridden.

    // attempt 2:
    // so another solution: single-stream OASIS *queries*, but offer discrete end-points for responses,
    //    and discrete endpoints for the plugins on queries
    //    ie:
    //      rpc register(RegistrationRequestDTO) returns (stream OASISQueryDTO) {}
    //      rpc offerRespondToOASISQueryABC(ABCResponseDTO) returns (ABCConfirmationDTO) {}
    //      rpc offerResponseToOASISQueryXYZ(XYZResponseDTO) returns (XYZConfirmationDTO) {}
    //      rpc askOASISAQuestion(1234QueryDTO) returns (1234ResponseDTO) {}
    //      rpc tellOASISToDoASDF(ASDFCommandDTO) returns (ASDFResponseDTO) {}
    //
    // [attempt 2.1]
    //    this implies 4 types of messages:
    //      CommandDTO
    //      QueryDTO
    //      ResponseDTO
    //      ConfirmDTO

    //attempt 3:
    // TBD. What are the nasty points? is there an implied grammar that we can simplify? What about testing?
    // regarding "query" vs "command", when we ask a plugin to evaluate something, we **want** it to be
    // ref-transparent (IE a query), but cheap-o implementations of the plugin arent going to do that,
    // they're going to forget to clean up their mesh or restore the model to a pre-simulation state,
    // potentially allowing pollution across simulation calls. Can the API address that?
    // Is there any way we can make it really clear, outside of documentation, that plugins should revert themselves
    // before cleaning-up?
    //    hows this: we create an OASIS command "CreateRestorePointCommand"
    //    then, during optimization runs, we submit "RestoreToPointCommand's" before each "EvaluationQuery"
    //    this would mean that users would have to explicitly decode "RestoreToCommand's" to do nothing.
    //    note: it also requires the black-boxes to become stateful in that there is no realistic expectation
    //    that the response to a "CreateRestorePoint" could contain any useful information about the current
    //    state of the simulation software, it would only be a name.

    // attempt 4: what about trying to keep streams limited to optimization?
    //    ie:
    //      rpc register(RegistrationRequestDTO) returns (stream OASISQueryDTO) {}
    //      rpc startOptimization(OptimizationStartCommandDTO) returns (OptimizationStartResponseDTO) {}
    //      rpc connectToOptimization(OptimizationResponseDTO) returns (stream NodeWorkRequestDTO) {}

    // attempt 4.1: nullability in proto3 is a mess!
    //   https://github.com/protocolbuffers/protobuf/issues/1606

    // entry-point, returns stream of OASIS queries/commands
    rpc registerRequest (RequestRegistrationCommandDTO) returns (stream RequestQueryDTO) {}
    rpc unregisterRequest (RequestUnRegistrationRequestDTO) returns (UnRegistrationResponseDTO) {}

    // commands/queries to OASIS
    rpc startOptimization (StartOptimizationCommandDTO) returns (StartOptimizationResponseDTO) {}
    rpc stopOptimization (StopOptimizationCommandDTO) returns (StopOptimizationResponseDTO) {}

    // responses to OASIS supplied queries
    rpc offerSimulationResult (SimulationResponseDTO) returns (SimulationResultConfirmDTO) {}
    rpc offerSimulationConfig (NodeStatusCommandOrResponseDTO) returns (NodeChangeConfirmDTO) {}
    rpc offerErrorResult (ErrorResponseDTO) returns (ErrorConfirmDTO) {}

    rpc sendMessage (MessageCommandDTO) returns (MessageResponseDTO) {}
    rpc updateNode (NodeStatusCommandOrResponseDTO) returns (NodeChangeConfirmDTO) {}
    rpc autoConfigure (NodeStatusCommandOrResponseDTO) returns (NodeChangeConfirmDTO) {}
    rpc changeNodeName (NodeNameChangeCommandDTO) returns (NodeNameChangeResponseDTO) {}

    rpc updateConfiguration(ConfigurationCommandDTO) returns (ConfigurationResponseDTO) {}
    rpc requestRunResult(ResultRequestDTO) returns (ResultResponseDTO) {}
}

message ConfigurationCommandDTO {
    string name = 1;
    Config config = 2;
    message Config{
        google.protobuf.Duration timeout = 2;
    }
}

message ConfigurationResponseDTO {
    bool updated = 1;
    string message =2;
}

//register
message RequestRegistrationCommandDTO {
    string name = 1;
}

message RequestUnRegistrationRequestDTO {
    string name = 1;
}

message UnRegistrationResponseDTO {
    string message = 1;
}

message MessageCommandDTO {
    string name = 1;
    string message = 2;
}

message MessageResponseDTO {}

message RequestQueryDTO {
    oneof request {
        SimulationEvaluationRequest evaluationRequest = 1;
        NodeStatusUpdateRequest nodeStatusRequest = 2;
        SimulationCancelRequest cancelRequest = 3;
        SimulationStartedRequest startRequest = 4;
        SimulationStoppedRequest stopRequest = 5;
    }

    message SimulationEvaluationRequest {
          string name = 1;
          map<string, double> inputVector = 2;
    }

    message NodeStatusUpdateRequest {
        string name = 1;
    }

    message SimulationCancelRequest {
        string name = 1;
    }

    message SimulationStartedRequest {
        string name = 1;
        string runID = 2;
    }

    message SimulationStoppedRequest {
        string name = 1;
        string runID = 2;
    }
}

//startOptimization
message StartOptimizationCommandDTO {
    string name = 1;
    RunConfiguration runConfig = 2;
}

message RunConfiguration {
    uint32 runNumber = 1;
    google.protobuf.Duration runTime = 2;
    uint32 iterationNumber = 3;
    double targetValue = 4;
}

message StartOptimizationResponseDTO {
    oneof response{
        string issues = 1;
        string runID = 2;
    }
}

//stopOptimization
message StopOptimizationCommandDTO {
    string name = 1;
    string id = 2;
}

message StopOptimizationResponseDTO {
    oneof response{
        string message = 1;
        string runID = 2;
    }
}

//request result
message ResultRequestDTO {
    string name = 1;
    string runID = 2;
}

message ResultResponseDTO {
    oneof response {
        string message = 1;
        RunResult RunResult = 2;
    }
}

message RunResult{
    string runID = 1;
    repeated Design point = 2;
    repeated Design optimum = 3; //Best value for single run and pareto frontier for multiple objective
}

message Design {
    map<string, double> input = 1;
    map<string, double> output = 2;
}

//updateNode
message SimulationResultConfirmDTO {}
message SimulationResponseDTO {
    string name = 1;
    map<string, double> outputVector = 2;
}
message ErrorConfirmDTO {}
message ErrorResponseDTO {
    string name = 1;
    string message = 2;
    string exception = 3;
}

//changeNodeName
message NodeNameChangeCommandDTO {
    string oldName = 1;
    string newName = 2;
}
message NodeNameChangeResponseDTO {
    bool changed = 1;
    string message = 2;
}

//offerNodeUpdate
message NodeStatusCommandOrResponseDTO {
    string name = 1;

    string description = 6;
    repeated PrototypeInputParameter inputs = 2;
    repeated PrototypeOutputParameter outputs = 3;

    message PrototypeInputParameter {
        string name = 1;

        //optional values
        double lowerBound = 2;
        double upperBound = 3;
        double currentValue = 4;
    }

    message PrototypeOutputParameter {
        string name = 1;

        //optional values
        oneof currentValue {
            double value = 2;
        }
    }
}

message NodeChangeConfirmDTO {
    string message = 1;
}
