# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

import optimizer_pb2 as optimizer__pb2


class FederatedOptimizerStub(object):
    """An optimizer that is updated by multiple different clients,
    who synchronize on the optimization and jointly manage its life cycle.
    TBD: the key feature this optimizer will export is that it will accept multiple tools registering at once
    this was the original goal of the API, and has prooven to be very complex.
    the idea is that multiple simulation clients can all access the same optimization at the same time,
    meaning an ANSA plugin and a NASTRAN plugin can both talk to the same optimizer,
    and each participate in an optimization

    unfortunately this necessitates a lot of state-sychronization,
    which raises the complexity level by an order of magnitude.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """


class FederatedOptimizerServicer(object):
    """An optimizer that is updated by multiple different clients,
    who synchronize on the optimization and jointly manage its life cycle.
    TBD: the key feature this optimizer will export is that it will accept multiple tools registering at once
    this was the original goal of the API, and has prooven to be very complex.
    the idea is that multiple simulation clients can all access the same optimization at the same time,
    meaning an ANSA plugin and a NASTRAN plugin can both talk to the same optimizer,
    and each participate in an optimization

    unfortunately this necessitates a lot of state-sychronization,
    which raises the complexity level by an order of magnitude.
    """


def add_FederatedOptimizerServicer_to_server(servicer, server):
    rpc_method_handlers = {
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'empowerops.volition.dto.FederatedOptimizer', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class FederatedOptimizer(object):
    """An optimizer that is updated by multiple different clients,
    who synchronize on the optimization and jointly manage its life cycle.
    TBD: the key feature this optimizer will export is that it will accept multiple tools registering at once
    this was the original goal of the API, and has prooven to be very complex.
    the idea is that multiple simulation clients can all access the same optimization at the same time,
    meaning an ANSA plugin and a NASTRAN plugin can both talk to the same optimizer,
    and each participate in an optimization

    unfortunately this necessitates a lot of state-sychronization,
    which raises the complexity level by an order of magnitude.
    """


class UnaryOptimizerStub(object):
    """some notes on naming scheme:
    "...QueryDTO" ->     a request for a ref-transparent ("getter") information.
    Results are sent via the in the "offer..." rpc methods;                     a "getX"
    "...ResponseDTO" ->  a result from a QueryDTO, sometimes passed from optimizer to simulator
    sometimes passed in the other direction;                                    result from "getX"
    "...CommandDTO" ->   a request to statefully change the configuration of the optimizer;          a "setX"
    "...ConfirmDTO" ->   the result of a Command, often indicates success or failure of the command; result from "setX"

    An optimizer that is started and stopped by a single client.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.StartOptimization = channel.unary_stream(
                '/empowerops.volition.dto.UnaryOptimizer/StartOptimization',
                request_serializer=optimizer__pb2.StartOptimizationCommandDTO.SerializeToString,
                response_deserializer=optimizer__pb2.OptimizerGeneratedQueryDTO.FromString,
                )
        self.OfferSimulationResult = channel.unary_unary(
                '/empowerops.volition.dto.UnaryOptimizer/OfferSimulationResult',
                request_serializer=optimizer__pb2.SimulationEvaluationCompletedResponseDTO.SerializeToString,
                response_deserializer=optimizer__pb2.SimulationEvaluationResultConfirmDTO.FromString,
                )
        self.OfferErrorResult = channel.unary_unary(
                '/empowerops.volition.dto.UnaryOptimizer/OfferErrorResult',
                request_serializer=optimizer__pb2.SimulationEvaluationErrorResponseDTO.SerializeToString,
                response_deserializer=optimizer__pb2.SimulationEvaluationErrorConfirmDTO.FromString,
                )
        self.OfferEvaluationStatusMessage = channel.unary_unary(
                '/empowerops.volition.dto.UnaryOptimizer/OfferEvaluationStatusMessage',
                request_serializer=optimizer__pb2.StatusMessageCommandDTO.SerializeToString,
                response_deserializer=optimizer__pb2.StatusMessageConfirmDTO.FromString,
                )
        self.StopOptimization = channel.unary_unary(
                '/empowerops.volition.dto.UnaryOptimizer/StopOptimization',
                request_serializer=optimizer__pb2.StopOptimizationCommandDTO.SerializeToString,
                response_deserializer=optimizer__pb2.StopOptimizationConfirmDTO.FromString,
                )
        self.RequestRunResult = channel.unary_unary(
                '/empowerops.volition.dto.UnaryOptimizer/RequestRunResult',
                request_serializer=optimizer__pb2.OptimizationResultsQueryDTO.SerializeToString,
                response_deserializer=optimizer__pb2.OptimizationResultsResponseDTO.FromString,
                )


class UnaryOptimizerServicer(object):
    """some notes on naming scheme:
    "...QueryDTO" ->     a request for a ref-transparent ("getter") information.
    Results are sent via the in the "offer..." rpc methods;                     a "getX"
    "...ResponseDTO" ->  a result from a QueryDTO, sometimes passed from optimizer to simulator
    sometimes passed in the other direction;                                    result from "getX"
    "...CommandDTO" ->   a request to statefully change the configuration of the optimizer;          a "setX"
    "...ConfirmDTO" ->   the result of a Command, often indicates success or failure of the command; result from "setX"

    An optimizer that is started and stopped by a single client.
    """

    def StartOptimization(self, request, context):
        """Starts an optimization of the specified problem definition and simulation nodes,
        and returns a stream of evaluation requests and other messages pertaining to the optimization.
        If the specified start request contains error, a stream is returned that contains a single message
        with a textual list of problems that prevented the run from starting. 

        If the optimization is started successfully,
        the messages returned by the stream will be as follows:
        OptimizationStartedNotification
        SimulationEvaluationRequest
        possibly: SimulationCancelRequest -- if the simulation takes too long or the optimization is stopped. 
        SimulationEvaluationRequest
        ... repeated until convergence criteria is met
        OptimizationFinishedNotification
        [stream completed]

        Uf the optimization cannot be started:
        OptimizationFailedToStartNotification -- will contain a list of issues indicating why the optimization was not started.
        [stream completed]
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def OfferSimulationResult(self, request, context):
        """Responses to OASIS supplied queries,
        these should be called by the simulator in response to OptimizerGeneratedQueryDTO messages.
        namely: every OptimizerGeneratedQueryDTO.SimulationEvaluationRequest must be followed by either
        an OfferSimulationResult call, or an OfferErrorResultCall.

        Offers the completed result of the simulation evaluation for the last provided SimulationEvaluationRequest
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def OfferErrorResult(self, request, context):
        """Offers an error to describe the completion of the last provided SimulationEvaluationRequest
        internally, the optimizer is likely to avoid areas it encounters errors,
        the optimizer will not try to evaluate the same point again.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def OfferEvaluationStatusMessage(self, request, context):
        """Offers a status update for the current running simulation evaluation.
        these messages are important for user experience in that they re-assure the user that the
        simulation is still running, and may be used to debug problems.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StopOptimization(self, request, context):
        """Stops a running optimization asynchronously.
        this method will likely send a SimulationCancelRequest to any running simulation
        it will return immediately, but the results from the simulation will not be available 
        until an OptimizationFinishedNotification is sent through the StartOptimization stream.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RequestRunResult(self, request, context):
        """Gets the results from a completed optimization 
        (that is, an optimization for which a OptimizationFinishedNotification has been sent)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_UnaryOptimizerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'StartOptimization': grpc.unary_stream_rpc_method_handler(
                    servicer.StartOptimization,
                    request_deserializer=optimizer__pb2.StartOptimizationCommandDTO.FromString,
                    response_serializer=optimizer__pb2.OptimizerGeneratedQueryDTO.SerializeToString,
            ),
            'OfferSimulationResult': grpc.unary_unary_rpc_method_handler(
                    servicer.OfferSimulationResult,
                    request_deserializer=optimizer__pb2.SimulationEvaluationCompletedResponseDTO.FromString,
                    response_serializer=optimizer__pb2.SimulationEvaluationResultConfirmDTO.SerializeToString,
            ),
            'OfferErrorResult': grpc.unary_unary_rpc_method_handler(
                    servicer.OfferErrorResult,
                    request_deserializer=optimizer__pb2.SimulationEvaluationErrorResponseDTO.FromString,
                    response_serializer=optimizer__pb2.SimulationEvaluationErrorConfirmDTO.SerializeToString,
            ),
            'OfferEvaluationStatusMessage': grpc.unary_unary_rpc_method_handler(
                    servicer.OfferEvaluationStatusMessage,
                    request_deserializer=optimizer__pb2.StatusMessageCommandDTO.FromString,
                    response_serializer=optimizer__pb2.StatusMessageConfirmDTO.SerializeToString,
            ),
            'StopOptimization': grpc.unary_unary_rpc_method_handler(
                    servicer.StopOptimization,
                    request_deserializer=optimizer__pb2.StopOptimizationCommandDTO.FromString,
                    response_serializer=optimizer__pb2.StopOptimizationConfirmDTO.SerializeToString,
            ),
            'RequestRunResult': grpc.unary_unary_rpc_method_handler(
                    servicer.RequestRunResult,
                    request_deserializer=optimizer__pb2.OptimizationResultsQueryDTO.FromString,
                    response_serializer=optimizer__pb2.OptimizationResultsResponseDTO.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'empowerops.volition.dto.UnaryOptimizer', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class UnaryOptimizer(object):
    """some notes on naming scheme:
    "...QueryDTO" ->     a request for a ref-transparent ("getter") information.
    Results are sent via the in the "offer..." rpc methods;                     a "getX"
    "...ResponseDTO" ->  a result from a QueryDTO, sometimes passed from optimizer to simulator
    sometimes passed in the other direction;                                    result from "getX"
    "...CommandDTO" ->   a request to statefully change the configuration of the optimizer;          a "setX"
    "...ConfirmDTO" ->   the result of a Command, often indicates success or failure of the command; result from "setX"

    An optimizer that is started and stopped by a single client.
    """

    @staticmethod
    def StartOptimization(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/empowerops.volition.dto.UnaryOptimizer/StartOptimization',
            optimizer__pb2.StartOptimizationCommandDTO.SerializeToString,
            optimizer__pb2.OptimizerGeneratedQueryDTO.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def OfferSimulationResult(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/empowerops.volition.dto.UnaryOptimizer/OfferSimulationResult',
            optimizer__pb2.SimulationEvaluationCompletedResponseDTO.SerializeToString,
            optimizer__pb2.SimulationEvaluationResultConfirmDTO.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def OfferErrorResult(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/empowerops.volition.dto.UnaryOptimizer/OfferErrorResult',
            optimizer__pb2.SimulationEvaluationErrorResponseDTO.SerializeToString,
            optimizer__pb2.SimulationEvaluationErrorConfirmDTO.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def OfferEvaluationStatusMessage(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/empowerops.volition.dto.UnaryOptimizer/OfferEvaluationStatusMessage',
            optimizer__pb2.StatusMessageCommandDTO.SerializeToString,
            optimizer__pb2.StatusMessageConfirmDTO.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StopOptimization(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/empowerops.volition.dto.UnaryOptimizer/StopOptimization',
            optimizer__pb2.StopOptimizationCommandDTO.SerializeToString,
            optimizer__pb2.StopOptimizationConfirmDTO.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def RequestRunResult(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/empowerops.volition.dto.UnaryOptimizer/RequestRunResult',
            optimizer__pb2.OptimizationResultsQueryDTO.SerializeToString,
            optimizer__pb2.OptimizationResultsResponseDTO.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
